{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/inherits/inherits.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/assert/assert.js","webpack:///./node_modules/object-assign/index.js","webpack:///./node_modules/script-loader/addScript.js","webpack:///./node_modules/console-browserify/index.js","webpack:///./lib/bundles/jquery-file-upload.js","webpack:///./vendor/blueimp/jquery-file-upload/js/jquery.fileupload.js?73ba","webpack:///./vendor/blueimp/jquery-file-upload/js/jquery.fileupload.js","webpack:///./vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport.js?f46b","webpack:///./vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/util/util.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/util/support/isBufferBrowser.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA;AACA,aAAa,mBAAO,CAAC,CAAM;AAC3B;AACA;AACA,CAAC;AACD,mBAAmB,mBAAO,CAAC,EAAuB;AAClD;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtBA,8CAAa;;AAEb,mBAAmB,mBAAO,CAAC,EAAe;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,CAAO;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B;AAC9B;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,oBAAoB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACzfA;AACA;AACA;AACA;AACA;;AAEa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;AC1BA;AACA,WAAW,mBAAO,CAAC,CAAM;AACzB,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,gCAAgC;AAChC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAO,CAAC,GAA8D;AACtE,mBAAO,CAAC,GAAoE;;;;;;;;ACjC5E,mBAAO,CAAC,CAAgE,EAAE,mBAAO,CAAC,GAA0M,E;;;;;;;ACA5R,iVAAiV,iBAAiB,qDAAqD,sGAAsG,KAAK,wCAAwC,8FAA8F,KAAK,OAAO,sDAAsD,KAAK,GAAG,gBAAgB,iBAAiB,8kBAA8kB,mbAAmb,wDAAwD,yNAAyN,6GAA6G,OAAO,iCAAiC,SAAS,uDAAuD,2CAA2C,2BAA2B,yEAAyE,0CAA0C,4IAA4I,oBAAoB,uBAAuB,6BAA6B,2BAA2B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DAAwD,WAAW,+BAA+B,yBAAyB,8LAA8L,aAAa,uBAAuB,4BAA4B,aAAa,WAAW,UAAU,OAAO,KAAK,EAAE,6oBAA6oB,mBAAmB,0CAA0C,oDAAoD,SAAS,2CAA2C,wEAAwE,SAAS,2CAA2C,oDAAoD,SAAS,0CAA0C,2CAA2C,kNAAkN,SAAS,6CAA6C,kEAAkE,SAAS,OAAO,KAAK,EAAE,GAAG,EAAE,G;;;;;;;ACA99R;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,CAAoB;;AAE/C;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,mBAAmB,mBAAO,CAAC,EAAU;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D,2BAA2B,mDAAmD;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9rBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA,C","file":"jquery-file-upload.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 500);\n","try {\n  var util = require('util');\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","'use strict';\n\nvar objectAssign = require('object-assign');\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","/*global window, global*/\nvar util = require(\"util\")\nvar assert = require(\"assert\")\nfunction now() { return new Date().getTime() }\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof global !== \"undefined\" && global.console) {\n    console = global.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, \"log\"],\n    [info, \"info\"],\n    [warn, \"warn\"],\n    [error, \"error\"],\n    [time, \"time\"],\n    [timeEnd, \"timeEnd\"],\n    [trace, \"trace\"],\n    [dir, \"dir\"],\n    [consoleAssert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    delete times[label]\n    var duration = now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n","/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2021 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\n// jQuery File Upload plugin\nrequire('../../vendor/blueimp/jquery-file-upload/js/jquery.fileupload');\nrequire('../../vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport');\n","require(\"!!/tmp/glpi-9.5.4/glpi/node_modules/script-loader/addScript.js\")(require(\"!!/tmp/glpi-9.5.4/glpi/node_modules/raw-loader/index.js!/tmp/glpi-9.5.4/glpi/node_modules/strip-sourcemap-loader/index.js!/tmp/glpi-9.5.4/glpi/vendor/blueimp/jquery-file-upload/js/jquery.fileupload.js\"))","module.exports = \"/*\\n * jQuery File Upload Plugin\\n * https://github.com/blueimp/jQuery-File-Upload\\n *\\n * Copyright 2010, Sebastian Tschan\\n * https://blueimp.net\\n *\\n * Licensed under the MIT license:\\n * https://opensource.org/licenses/MIT\\n */\\n\\n/* global define, require */\\n/* eslint-disable new-cap */\\n\\n(function (factory) {\\n  'use strict';\\n  if (typeof define === 'function' && define.amd) {\\n    // Register as an anonymous AMD module:\\n    define(['jquery', 'jquery-ui/ui/widget'], factory);\\n  } else if (typeof exports === 'object') {\\n    // Node/CommonJS:\\n    factory(require('jquery'), require('./vendor/jquery.ui.widget'));\\n  } else {\\n    // Browser globals:\\n    factory(window.jQuery);\\n  }\\n})(function ($) {\\n  'use strict';\\n\\n  // Detect file input support, based on\\n  // https://viljamis.com/2012/file-upload-support-on-mobile/\\n  $.support.fileInput = !(\\n    new RegExp(\\n      // Handle devices which give false positives for the feature detection:\\n      '(Android (1\\\\\\\\.[0156]|2\\\\\\\\.[01]))' +\\n        '|(Windows Phone (OS 7|8\\\\\\\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +\\n        '|(w(eb)?OSBrowser)|(webOS)' +\\n        '|(Kindle/(1\\\\\\\\.0|2\\\\\\\\.[05]|3\\\\\\\\.0))'\\n    ).test(window.navigator.userAgent) ||\\n    // Feature detection for all other devices:\\n    $('<input type=\\\"file\\\"/>').prop('disabled')\\n  );\\n\\n  // The FileReader API is not actually used, but works as feature detection,\\n  // as some Safari versions (5?) support XHR file uploads via the FormData API,\\n  // but not non-multipart XHR file uploads.\\n  // window.XMLHttpRequestUpload is not available on IE10, so we check for\\n  // window.ProgressEvent instead to detect XHR2 file upload capability:\\n  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);\\n  $.support.xhrFormDataFileUpload = !!window.FormData;\\n\\n  // Detect support for Blob slicing (required for chunked uploads):\\n  $.support.blobSlice =\\n    window.Blob &&\\n    (Blob.prototype.slice ||\\n      Blob.prototype.webkitSlice ||\\n      Blob.prototype.mozSlice);\\n\\n  /**\\n   * Helper function to create drag handlers for dragover/dragenter/dragleave\\n   *\\n   * @param {string} type Event type\\n   * @returns {Function} Drag handler\\n   */\\n  function getDragHandler(type) {\\n    var isDragOver = type === 'dragover';\\n    return function (e) {\\n      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\\n      var dataTransfer = e.dataTransfer;\\n      if (\\n        dataTransfer &&\\n        $.inArray('Files', dataTransfer.types) !== -1 &&\\n        this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false\\n      ) {\\n        e.preventDefault();\\n        if (isDragOver) {\\n          dataTransfer.dropEffect = 'copy';\\n        }\\n      }\\n    };\\n  }\\n\\n  // The fileupload widget listens for change events on file input fields defined\\n  // via fileInput setting and paste or drop events of the given dropZone.\\n  // In addition to the default jQuery Widget methods, the fileupload widget\\n  // exposes the \\\"add\\\" and \\\"send\\\" methods, to add or directly send files using\\n  // the fileupload API.\\n  // By default, files added via file input selection, paste, drag & drop or\\n  // \\\"add\\\" method are uploaded immediately, but it is possible to override\\n  // the \\\"add\\\" callback option to queue file uploads.\\n  $.widget('blueimp.fileupload', {\\n    options: {\\n      // The drop target element(s), by the default the complete document.\\n      // Set to null to disable drag & drop support:\\n      dropZone: $(document),\\n      // The paste target element(s), by the default undefined.\\n      // Set to a DOM node or jQuery object to enable file pasting:\\n      pasteZone: undefined,\\n      // The file input field(s), that are listened to for change events.\\n      // If undefined, it is set to the file input fields inside\\n      // of the widget element on plugin initialization.\\n      // Set to null to disable the change listener.\\n      fileInput: undefined,\\n      // By default, the file input field is replaced with a clone after\\n      // each input field change event. This is required for iframe transport\\n      // queues and allows change events to be fired for the same file\\n      // selection, but can be disabled by setting the following option to false:\\n      replaceFileInput: true,\\n      // The parameter name for the file form data (the request argument name).\\n      // If undefined or empty, the name property of the file input field is\\n      // used, or \\\"files[]\\\" if the file input name property is also empty,\\n      // can be a string or an array of strings:\\n      paramName: undefined,\\n      // By default, each file of a selection is uploaded using an individual\\n      // request for XHR type uploads. Set to false to upload file\\n      // selections in one request each:\\n      singleFileUploads: true,\\n      // To limit the number of files uploaded with one XHR request,\\n      // set the following option to an integer greater than 0:\\n      limitMultiFileUploads: undefined,\\n      // The following option limits the number of files uploaded with one\\n      // XHR request to keep the request size under or equal to the defined\\n      // limit in bytes:\\n      limitMultiFileUploadSize: undefined,\\n      // Multipart file uploads add a number of bytes to each uploaded file,\\n      // therefore the following option adds an overhead for each file used\\n      // in the limitMultiFileUploadSize configuration:\\n      limitMultiFileUploadSizeOverhead: 512,\\n      // Set the following option to true to issue all file upload requests\\n      // in a sequential order:\\n      sequentialUploads: false,\\n      // To limit the number of concurrent uploads,\\n      // set the following option to an integer greater than 0:\\n      limitConcurrentUploads: undefined,\\n      // Set the following option to true to force iframe transport uploads:\\n      forceIframeTransport: false,\\n      // Set the following option to the location of a redirect url on the\\n      // origin server, for cross-domain iframe transport uploads:\\n      redirect: undefined,\\n      // The parameter name for the redirect url, sent as part of the form\\n      // data and set to 'redirect' if this option is empty:\\n      redirectParamName: undefined,\\n      // Set the following option to the location of a postMessage window,\\n      // to enable postMessage transport uploads:\\n      postMessage: undefined,\\n      // By default, XHR file uploads are sent as multipart/form-data.\\n      // The iframe transport is always using multipart/form-data.\\n      // Set to false to enable non-multipart XHR uploads:\\n      multipart: true,\\n      // To upload large files in smaller chunks, set the following option\\n      // to a preferred maximum chunk size. If set to 0, null or undefined,\\n      // or the browser does not support the required Blob API, files will\\n      // be uploaded as a whole.\\n      maxChunkSize: undefined,\\n      // When a non-multipart upload or a chunked multipart upload has been\\n      // aborted, this option can be used to resume the upload by setting\\n      // it to the size of the already uploaded bytes. This option is most\\n      // useful when modifying the options object inside of the \\\"add\\\" or\\n      // \\\"send\\\" callbacks, as the options are cloned for each file upload.\\n      uploadedBytes: undefined,\\n      // By default, failed (abort or error) file uploads are removed from the\\n      // global progress calculation. Set the following option to false to\\n      // prevent recalculating the global progress data:\\n      recalculateProgress: true,\\n      // Interval in milliseconds to calculate and trigger progress events:\\n      progressInterval: 100,\\n      // Interval in milliseconds to calculate progress bitrate:\\n      bitrateInterval: 500,\\n      // By default, uploads are started automatically when adding files:\\n      autoUpload: true,\\n      // By default, duplicate file names are expected to be handled on\\n      // the server-side. If this is not possible (e.g. when uploading\\n      // files directly to Amazon S3), the following option can be set to\\n      // an empty object or an object mapping existing filenames, e.g.:\\n      // { \\\"image.jpg\\\": true, \\\"image (1).jpg\\\": true }\\n      // If it is set, all files will be uploaded with unique filenames,\\n      // adding increasing number suffixes if necessary, e.g.:\\n      // \\\"image (2).jpg\\\"\\n      uniqueFilenames: undefined,\\n\\n      // Error and info messages:\\n      messages: {\\n        uploadedBytes: 'Uploaded bytes exceed file size'\\n      },\\n\\n      // Translation function, gets the message key to be translated\\n      // and an object with context specific data as arguments:\\n      i18n: function (message, context) {\\n        // eslint-disable-next-line no-param-reassign\\n        message = this.messages[message] || message.toString();\\n        if (context) {\\n          $.each(context, function (key, value) {\\n            // eslint-disable-next-line no-param-reassign\\n            message = message.replace('{' + key + '}', value);\\n          });\\n        }\\n        return message;\\n      },\\n\\n      // Additional form data to be sent along with the file uploads can be set\\n      // using this option, which accepts an array of objects with name and\\n      // value properties, a function returning such an array, a FormData\\n      // object (for XHR file uploads), or a simple object.\\n      // The form of the first fileInput is given as parameter to the function:\\n      formData: function (form) {\\n        return form.serializeArray();\\n      },\\n\\n      // The add callback is invoked as soon as files are added to the fileupload\\n      // widget (via file input selection, drag & drop, paste or add API call).\\n      // If the singleFileUploads option is enabled, this callback will be\\n      // called once for each file in the selection for XHR file uploads, else\\n      // once for each file selection.\\n      //\\n      // The upload starts when the submit method is invoked on the data parameter.\\n      // The data object contains a files property holding the added files\\n      // and allows you to override plugin options as well as define ajax settings.\\n      //\\n      // Listeners for this callback can also be bound the following way:\\n      // .on('fileuploadadd', func);\\n      //\\n      // data.submit() returns a Promise object and allows to attach additional\\n      // handlers using jQuery's Deferred callbacks:\\n      // data.submit().done(func).fail(func).always(func);\\n      add: function (e, data) {\\n        if (e.isDefaultPrevented()) {\\n          return false;\\n        }\\n        if (\\n          data.autoUpload ||\\n          (data.autoUpload !== false &&\\n            $(this).fileupload('option', 'autoUpload'))\\n        ) {\\n          data.process().done(function () {\\n            data.submit();\\n          });\\n        }\\n      },\\n\\n      // Other callbacks:\\n\\n      // Callback for the submit event of each file upload:\\n      // submit: function (e, data) {}, // .on('fileuploadsubmit', func);\\n\\n      // Callback for the start of each file upload request:\\n      // send: function (e, data) {}, // .on('fileuploadsend', func);\\n\\n      // Callback for successful uploads:\\n      // done: function (e, data) {}, // .on('fileuploaddone', func);\\n\\n      // Callback for failed (abort or error) uploads:\\n      // fail: function (e, data) {}, // .on('fileuploadfail', func);\\n\\n      // Callback for completed (success, abort or error) requests:\\n      // always: function (e, data) {}, // .on('fileuploadalways', func);\\n\\n      // Callback for upload progress events:\\n      // progress: function (e, data) {}, // .on('fileuploadprogress', func);\\n\\n      // Callback for global upload progress events:\\n      // progressall: function (e, data) {}, // .on('fileuploadprogressall', func);\\n\\n      // Callback for uploads start, equivalent to the global ajaxStart event:\\n      // start: function (e) {}, // .on('fileuploadstart', func);\\n\\n      // Callback for uploads stop, equivalent to the global ajaxStop event:\\n      // stop: function (e) {}, // .on('fileuploadstop', func);\\n\\n      // Callback for change events of the fileInput(s):\\n      // change: function (e, data) {}, // .on('fileuploadchange', func);\\n\\n      // Callback for paste events to the pasteZone(s):\\n      // paste: function (e, data) {}, // .on('fileuploadpaste', func);\\n\\n      // Callback for drop events of the dropZone(s):\\n      // drop: function (e, data) {}, // .on('fileuploaddrop', func);\\n\\n      // Callback for dragover events of the dropZone(s):\\n      // dragover: function (e) {}, // .on('fileuploaddragover', func);\\n\\n      // Callback before the start of each chunk upload request (before form data initialization):\\n      // chunkbeforesend: function (e, data) {}, // .on('fileuploadchunkbeforesend', func);\\n\\n      // Callback for the start of each chunk upload request:\\n      // chunksend: function (e, data) {}, // .on('fileuploadchunksend', func);\\n\\n      // Callback for successful chunk uploads:\\n      // chunkdone: function (e, data) {}, // .on('fileuploadchunkdone', func);\\n\\n      // Callback for failed (abort or error) chunk uploads:\\n      // chunkfail: function (e, data) {}, // .on('fileuploadchunkfail', func);\\n\\n      // Callback for completed (success, abort or error) chunk upload requests:\\n      // chunkalways: function (e, data) {}, // .on('fileuploadchunkalways', func);\\n\\n      // The plugin options are used as settings object for the ajax calls.\\n      // The following are jQuery ajax settings required for the file uploads:\\n      processData: false,\\n      contentType: false,\\n      cache: false,\\n      timeout: 0\\n    },\\n\\n    // jQuery versions before 1.8 require promise.pipe if the return value is\\n    // used, as promise.then in older versions has a different behavior, see:\\n    // https://blog.jquery.com/2012/08/09/jquery-1-8-released/\\n    // https://bugs.jquery.com/ticket/11010\\n    // https://github.com/blueimp/jQuery-File-Upload/pull/3435\\n    _promisePipe: (function () {\\n      var parts = $.fn.jquery.split('.');\\n      return Number(parts[0]) > 1 || Number(parts[1]) > 7 ? 'then' : 'pipe';\\n    })(),\\n\\n    // A list of options that require reinitializing event listeners and/or\\n    // special initialization code:\\n    _specialOptions: [\\n      'fileInput',\\n      'dropZone',\\n      'pasteZone',\\n      'multipart',\\n      'forceIframeTransport'\\n    ],\\n\\n    _blobSlice:\\n      $.support.blobSlice &&\\n      function () {\\n        var slice = this.slice || this.webkitSlice || this.mozSlice;\\n        return slice.apply(this, arguments);\\n      },\\n\\n    _BitrateTimer: function () {\\n      this.timestamp = Date.now ? Date.now() : new Date().getTime();\\n      this.loaded = 0;\\n      this.bitrate = 0;\\n      this.getBitrate = function (now, loaded, interval) {\\n        var timeDiff = now - this.timestamp;\\n        if (!this.bitrate || !interval || timeDiff > interval) {\\n          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\\n          this.loaded = loaded;\\n          this.timestamp = now;\\n        }\\n        return this.bitrate;\\n      };\\n    },\\n\\n    _isXHRUpload: function (options) {\\n      return (\\n        !options.forceIframeTransport &&\\n        ((!options.multipart && $.support.xhrFileUpload) ||\\n          $.support.xhrFormDataFileUpload)\\n      );\\n    },\\n\\n    _getFormData: function (options) {\\n      var formData;\\n      if ($.type(options.formData) === 'function') {\\n        return options.formData(options.form);\\n      }\\n      if ($.isArray(options.formData)) {\\n        return options.formData;\\n      }\\n      if ($.type(options.formData) === 'object') {\\n        formData = [];\\n        $.each(options.formData, function (name, value) {\\n          formData.push({ name: name, value: value });\\n        });\\n        return formData;\\n      }\\n      return [];\\n    },\\n\\n    _getTotal: function (files) {\\n      var total = 0;\\n      $.each(files, function (index, file) {\\n        total += file.size || 1;\\n      });\\n      return total;\\n    },\\n\\n    _initProgressObject: function (obj) {\\n      var progress = {\\n        loaded: 0,\\n        total: 0,\\n        bitrate: 0\\n      };\\n      if (obj._progress) {\\n        $.extend(obj._progress, progress);\\n      } else {\\n        obj._progress = progress;\\n      }\\n    },\\n\\n    _initResponseObject: function (obj) {\\n      var prop;\\n      if (obj._response) {\\n        for (prop in obj._response) {\\n          if (Object.prototype.hasOwnProperty.call(obj._response, prop)) {\\n            delete obj._response[prop];\\n          }\\n        }\\n      } else {\\n        obj._response = {};\\n      }\\n    },\\n\\n    _onProgress: function (e, data) {\\n      if (e.lengthComputable) {\\n        var now = Date.now ? Date.now() : new Date().getTime(),\\n          loaded;\\n        if (\\n          data._time &&\\n          data.progressInterval &&\\n          now - data._time < data.progressInterval &&\\n          e.loaded !== e.total\\n        ) {\\n          return;\\n        }\\n        data._time = now;\\n        loaded =\\n          Math.floor(\\n            (e.loaded / e.total) * (data.chunkSize || data._progress.total)\\n          ) + (data.uploadedBytes || 0);\\n        // Add the difference from the previously loaded state\\n        // to the global loaded counter:\\n        this._progress.loaded += loaded - data._progress.loaded;\\n        this._progress.bitrate = this._bitrateTimer.getBitrate(\\n          now,\\n          this._progress.loaded,\\n          data.bitrateInterval\\n        );\\n        data._progress.loaded = data.loaded = loaded;\\n        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\\n          now,\\n          loaded,\\n          data.bitrateInterval\\n        );\\n        // Trigger a custom progress event with a total data property set\\n        // to the file size(s) of the current upload and a loaded data\\n        // property calculated accordingly:\\n        this._trigger(\\n          'progress',\\n          $.Event('progress', { delegatedEvent: e }),\\n          data\\n        );\\n        // Trigger a global progress event for all current file uploads,\\n        // including ajax calls queued for sequential file uploads:\\n        this._trigger(\\n          'progressall',\\n          $.Event('progressall', { delegatedEvent: e }),\\n          this._progress\\n        );\\n      }\\n    },\\n\\n    _initProgressListener: function (options) {\\n      var that = this,\\n        xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\\n      // Accesss to the native XHR object is required to add event listeners\\n      // for the upload progress event:\\n      if (xhr.upload) {\\n        $(xhr.upload).on('progress', function (e) {\\n          var oe = e.originalEvent;\\n          // Make sure the progress event properties get copied over:\\n          e.lengthComputable = oe.lengthComputable;\\n          e.loaded = oe.loaded;\\n          e.total = oe.total;\\n          that._onProgress(e, options);\\n        });\\n        options.xhr = function () {\\n          return xhr;\\n        };\\n      }\\n    },\\n\\n    _deinitProgressListener: function (options) {\\n      var xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\\n      if (xhr.upload) {\\n        $(xhr.upload).off('progress');\\n      }\\n    },\\n\\n    _isInstanceOf: function (type, obj) {\\n      // Cross-frame instanceof check\\n      return Object.prototype.toString.call(obj) === '[object ' + type + ']';\\n    },\\n\\n    _getUniqueFilename: function (name, map) {\\n      // eslint-disable-next-line no-param-reassign\\n      name = String(name);\\n      if (map[name]) {\\n        // eslint-disable-next-line no-param-reassign\\n        name = name.replace(/(?: \\\\(([\\\\d]+)\\\\))?(\\\\.[^.]+)?$/, function (\\n          _,\\n          p1,\\n          p2\\n        ) {\\n          var index = p1 ? Number(p1) + 1 : 1;\\n          var ext = p2 || '';\\n          return ' (' + index + ')' + ext;\\n        });\\n        return this._getUniqueFilename(name, map);\\n      }\\n      map[name] = true;\\n      return name;\\n    },\\n\\n    _initXHRData: function (options) {\\n      var that = this,\\n        formData,\\n        file = options.files[0],\\n        // Ignore non-multipart setting if not supported:\\n        multipart = options.multipart || !$.support.xhrFileUpload,\\n        paramName =\\n          $.type(options.paramName) === 'array'\\n            ? options.paramName[0]\\n            : options.paramName;\\n      options.headers = $.extend({}, options.headers);\\n      if (options.contentRange) {\\n        options.headers['Content-Range'] = options.contentRange;\\n      }\\n      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {\\n        options.headers['Content-Disposition'] =\\n          'attachment; filename=\\\"' +\\n          encodeURI(file.uploadName || file.name) +\\n          '\\\"';\\n      }\\n      if (!multipart) {\\n        options.contentType = file.type || 'application/octet-stream';\\n        options.data = options.blob || file;\\n      } else if ($.support.xhrFormDataFileUpload) {\\n        if (options.postMessage) {\\n          // window.postMessage does not allow sending FormData\\n          // objects, so we just add the File/Blob objects to\\n          // the formData array and let the postMessage window\\n          // create the FormData object out of this array:\\n          formData = this._getFormData(options);\\n          if (options.blob) {\\n            formData.push({\\n              name: paramName,\\n              value: options.blob\\n            });\\n          } else {\\n            $.each(options.files, function (index, file) {\\n              formData.push({\\n                name:\\n                  ($.type(options.paramName) === 'array' &&\\n                    options.paramName[index]) ||\\n                  paramName,\\n                value: file\\n              });\\n            });\\n          }\\n        } else {\\n          if (that._isInstanceOf('FormData', options.formData)) {\\n            formData = options.formData;\\n          } else {\\n            formData = new FormData();\\n            $.each(this._getFormData(options), function (index, field) {\\n              formData.append(field.name, field.value);\\n            });\\n          }\\n          if (options.blob) {\\n            formData.append(\\n              paramName,\\n              options.blob,\\n              file.uploadName || file.name\\n            );\\n          } else {\\n            $.each(options.files, function (index, file) {\\n              // This check allows the tests to run with\\n              // dummy objects:\\n              if (\\n                that._isInstanceOf('File', file) ||\\n                that._isInstanceOf('Blob', file)\\n              ) {\\n                var fileName = file.uploadName || file.name;\\n                if (options.uniqueFilenames) {\\n                  fileName = that._getUniqueFilename(\\n                    fileName,\\n                    options.uniqueFilenames\\n                  );\\n                }\\n                formData.append(\\n                  ($.type(options.paramName) === 'array' &&\\n                    options.paramName[index]) ||\\n                    paramName,\\n                  file,\\n                  fileName\\n                );\\n              }\\n            });\\n          }\\n        }\\n        options.data = formData;\\n      }\\n      // Blob reference is not needed anymore, free memory:\\n      options.blob = null;\\n    },\\n\\n    _initIframeSettings: function (options) {\\n      var targetHost = $('<a></a>').prop('href', options.url).prop('host');\\n      // Setting the dataType to iframe enables the iframe transport:\\n      options.dataType = 'iframe ' + (options.dataType || '');\\n      // The iframe transport accepts a serialized array as form data:\\n      options.formData = this._getFormData(options);\\n      // Add redirect url to form data on cross-domain uploads:\\n      if (options.redirect && targetHost && targetHost !== location.host) {\\n        options.formData.push({\\n          name: options.redirectParamName || 'redirect',\\n          value: options.redirect\\n        });\\n      }\\n    },\\n\\n    _initDataSettings: function (options) {\\n      if (this._isXHRUpload(options)) {\\n        if (!this._chunkedUpload(options, true)) {\\n          if (!options.data) {\\n            this._initXHRData(options);\\n          }\\n          this._initProgressListener(options);\\n        }\\n        if (options.postMessage) {\\n          // Setting the dataType to postmessage enables the\\n          // postMessage transport:\\n          options.dataType = 'postmessage ' + (options.dataType || '');\\n        }\\n      } else {\\n        this._initIframeSettings(options);\\n      }\\n    },\\n\\n    _getParamName: function (options) {\\n      var fileInput = $(options.fileInput),\\n        paramName = options.paramName;\\n      if (!paramName) {\\n        paramName = [];\\n        fileInput.each(function () {\\n          var input = $(this),\\n            name = input.prop('name') || 'files[]',\\n            i = (input.prop('files') || [1]).length;\\n          while (i) {\\n            paramName.push(name);\\n            i -= 1;\\n          }\\n        });\\n        if (!paramName.length) {\\n          paramName = [fileInput.prop('name') || 'files[]'];\\n        }\\n      } else if (!$.isArray(paramName)) {\\n        paramName = [paramName];\\n      }\\n      return paramName;\\n    },\\n\\n    _initFormSettings: function (options) {\\n      // Retrieve missing options from the input field and the\\n      // associated form, if available:\\n      if (!options.form || !options.form.length) {\\n        options.form = $(options.fileInput.prop('form'));\\n        // If the given file input doesn't have an associated form,\\n        // use the default widget file input's form:\\n        if (!options.form.length) {\\n          options.form = $(this.options.fileInput.prop('form'));\\n        }\\n      }\\n      options.paramName = this._getParamName(options);\\n      if (!options.url) {\\n        options.url = options.form.prop('action') || location.href;\\n      }\\n      // The HTTP request method must be \\\"POST\\\" or \\\"PUT\\\":\\n      options.type = (\\n        options.type ||\\n        ($.type(options.form.prop('method')) === 'string' &&\\n          options.form.prop('method')) ||\\n        ''\\n      ).toUpperCase();\\n      if (\\n        options.type !== 'POST' &&\\n        options.type !== 'PUT' &&\\n        options.type !== 'PATCH'\\n      ) {\\n        options.type = 'POST';\\n      }\\n      if (!options.formAcceptCharset) {\\n        options.formAcceptCharset = options.form.attr('accept-charset');\\n      }\\n    },\\n\\n    _getAJAXSettings: function (data) {\\n      var options = $.extend({}, this.options, data);\\n      this._initFormSettings(options);\\n      this._initDataSettings(options);\\n      return options;\\n    },\\n\\n    // jQuery 1.6 doesn't provide .state(),\\n    // while jQuery 1.8+ removed .isRejected() and .isResolved():\\n    _getDeferredState: function (deferred) {\\n      if (deferred.state) {\\n        return deferred.state();\\n      }\\n      if (deferred.isResolved()) {\\n        return 'resolved';\\n      }\\n      if (deferred.isRejected()) {\\n        return 'rejected';\\n      }\\n      return 'pending';\\n    },\\n\\n    // Maps jqXHR callbacks to the equivalent\\n    // methods of the given Promise object:\\n    _enhancePromise: function (promise) {\\n      promise.success = promise.done;\\n      promise.error = promise.fail;\\n      promise.complete = promise.always;\\n      return promise;\\n    },\\n\\n    // Creates and returns a Promise object enhanced with\\n    // the jqXHR methods abort, success, error and complete:\\n    _getXHRPromise: function (resolveOrReject, context, args) {\\n      var dfd = $.Deferred(),\\n        promise = dfd.promise();\\n      // eslint-disable-next-line no-param-reassign\\n      context = context || this.options.context || promise;\\n      if (resolveOrReject === true) {\\n        dfd.resolveWith(context, args);\\n      } else if (resolveOrReject === false) {\\n        dfd.rejectWith(context, args);\\n      }\\n      promise.abort = dfd.promise;\\n      return this._enhancePromise(promise);\\n    },\\n\\n    // Adds convenience methods to the data callback argument:\\n    _addConvenienceMethods: function (e, data) {\\n      var that = this,\\n        getPromise = function (args) {\\n          return $.Deferred().resolveWith(that, args).promise();\\n        };\\n      data.process = function (resolveFunc, rejectFunc) {\\n        if (resolveFunc || rejectFunc) {\\n          data._processQueue = this._processQueue = (this._processQueue ||\\n            getPromise([this]))\\n            [that._promisePipe](function () {\\n              if (data.errorThrown) {\\n                return $.Deferred().rejectWith(that, [data]).promise();\\n              }\\n              return getPromise(arguments);\\n            })\\n            [that._promisePipe](resolveFunc, rejectFunc);\\n        }\\n        return this._processQueue || getPromise([this]);\\n      };\\n      data.submit = function () {\\n        if (this.state() !== 'pending') {\\n          data.jqXHR = this.jqXHR =\\n            that._trigger(\\n              'submit',\\n              $.Event('submit', { delegatedEvent: e }),\\n              this\\n            ) !== false && that._onSend(e, this);\\n        }\\n        return this.jqXHR || that._getXHRPromise();\\n      };\\n      data.abort = function () {\\n        if (this.jqXHR) {\\n          return this.jqXHR.abort();\\n        }\\n        this.errorThrown = 'abort';\\n        that._trigger('fail', null, this);\\n        return that._getXHRPromise(false);\\n      };\\n      data.state = function () {\\n        if (this.jqXHR) {\\n          return that._getDeferredState(this.jqXHR);\\n        }\\n        if (this._processQueue) {\\n          return that._getDeferredState(this._processQueue);\\n        }\\n      };\\n      data.processing = function () {\\n        return (\\n          !this.jqXHR &&\\n          this._processQueue &&\\n          that._getDeferredState(this._processQueue) === 'pending'\\n        );\\n      };\\n      data.progress = function () {\\n        return this._progress;\\n      };\\n      data.response = function () {\\n        return this._response;\\n      };\\n    },\\n\\n    // Parses the Range header from the server response\\n    // and returns the uploaded bytes:\\n    _getUploadedBytes: function (jqXHR) {\\n      var range = jqXHR.getResponseHeader('Range'),\\n        parts = range && range.split('-'),\\n        upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);\\n      return upperBytesPos && upperBytesPos + 1;\\n    },\\n\\n    // Uploads a file in multiple, sequential requests\\n    // by splitting the file up in multiple blob chunks.\\n    // If the second parameter is true, only tests if the file\\n    // should be uploaded in chunks, but does not invoke any\\n    // upload requests:\\n    _chunkedUpload: function (options, testOnly) {\\n      options.uploadedBytes = options.uploadedBytes || 0;\\n      var that = this,\\n        file = options.files[0],\\n        fs = file.size,\\n        ub = options.uploadedBytes,\\n        mcs = options.maxChunkSize || fs,\\n        slice = this._blobSlice,\\n        dfd = $.Deferred(),\\n        promise = dfd.promise(),\\n        jqXHR,\\n        upload;\\n      if (\\n        !(\\n          this._isXHRUpload(options) &&\\n          slice &&\\n          (ub || ($.type(mcs) === 'function' ? mcs(options) : mcs) < fs)\\n        ) ||\\n        options.data\\n      ) {\\n        return false;\\n      }\\n      if (testOnly) {\\n        return true;\\n      }\\n      if (ub >= fs) {\\n        file.error = options.i18n('uploadedBytes');\\n        return this._getXHRPromise(false, options.context, [\\n          null,\\n          'error',\\n          file.error\\n        ]);\\n      }\\n      // The chunk upload method:\\n      upload = function () {\\n        // Clone the options object for each chunk upload:\\n        var o = $.extend({}, options),\\n          currentLoaded = o._progress.loaded;\\n        o.blob = slice.call(\\n          file,\\n          ub,\\n          ub + ($.type(mcs) === 'function' ? mcs(o) : mcs),\\n          file.type\\n        );\\n        // Store the current chunk size, as the blob itself\\n        // will be dereferenced after data processing:\\n        o.chunkSize = o.blob.size;\\n        // Expose the chunk bytes position range:\\n        o.contentRange =\\n          'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;\\n        // Trigger chunkbeforesend to allow form data to be updated for this chunk\\n        that._trigger('chunkbeforesend', null, o);\\n        // Process the upload data (the blob and potential form data):\\n        that._initXHRData(o);\\n        // Add progress listeners for this chunk upload:\\n        that._initProgressListener(o);\\n        jqXHR = (\\n          (that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||\\n          that._getXHRPromise(false, o.context)\\n        )\\n          .done(function (result, textStatus, jqXHR) {\\n            ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;\\n            // Create a progress event if no final progress event\\n            // with loaded equaling total has been triggered\\n            // for this chunk:\\n            if (currentLoaded + o.chunkSize - o._progress.loaded) {\\n              that._onProgress(\\n                $.Event('progress', {\\n                  lengthComputable: true,\\n                  loaded: ub - o.uploadedBytes,\\n                  total: ub - o.uploadedBytes\\n                }),\\n                o\\n              );\\n            }\\n            options.uploadedBytes = o.uploadedBytes = ub;\\n            o.result = result;\\n            o.textStatus = textStatus;\\n            o.jqXHR = jqXHR;\\n            that._trigger('chunkdone', null, o);\\n            that._trigger('chunkalways', null, o);\\n            if (ub < fs) {\\n              // File upload not yet complete,\\n              // continue with the next chunk:\\n              upload();\\n            } else {\\n              dfd.resolveWith(o.context, [result, textStatus, jqXHR]);\\n            }\\n          })\\n          .fail(function (jqXHR, textStatus, errorThrown) {\\n            o.jqXHR = jqXHR;\\n            o.textStatus = textStatus;\\n            o.errorThrown = errorThrown;\\n            that._trigger('chunkfail', null, o);\\n            that._trigger('chunkalways', null, o);\\n            dfd.rejectWith(o.context, [jqXHR, textStatus, errorThrown]);\\n          })\\n          .always(function () {\\n            that._deinitProgressListener(o);\\n          });\\n      };\\n      this._enhancePromise(promise);\\n      promise.abort = function () {\\n        return jqXHR.abort();\\n      };\\n      upload();\\n      return promise;\\n    },\\n\\n    _beforeSend: function (e, data) {\\n      if (this._active === 0) {\\n        // the start callback is triggered when an upload starts\\n        // and no other uploads are currently running,\\n        // equivalent to the global ajaxStart event:\\n        this._trigger('start');\\n        // Set timer for global bitrate progress calculation:\\n        this._bitrateTimer = new this._BitrateTimer();\\n        // Reset the global progress values:\\n        this._progress.loaded = this._progress.total = 0;\\n        this._progress.bitrate = 0;\\n      }\\n      // Make sure the container objects for the .response() and\\n      // .progress() methods on the data object are available\\n      // and reset to their initial state:\\n      this._initResponseObject(data);\\n      this._initProgressObject(data);\\n      data._progress.loaded = data.loaded = data.uploadedBytes || 0;\\n      data._progress.total = data.total = this._getTotal(data.files) || 1;\\n      data._progress.bitrate = data.bitrate = 0;\\n      this._active += 1;\\n      // Initialize the global progress values:\\n      this._progress.loaded += data.loaded;\\n      this._progress.total += data.total;\\n    },\\n\\n    _onDone: function (result, textStatus, jqXHR, options) {\\n      var total = options._progress.total,\\n        response = options._response;\\n      if (options._progress.loaded < total) {\\n        // Create a progress event if no final progress event\\n        // with loaded equaling total has been triggered:\\n        this._onProgress(\\n          $.Event('progress', {\\n            lengthComputable: true,\\n            loaded: total,\\n            total: total\\n          }),\\n          options\\n        );\\n      }\\n      response.result = options.result = result;\\n      response.textStatus = options.textStatus = textStatus;\\n      response.jqXHR = options.jqXHR = jqXHR;\\n      this._trigger('done', null, options);\\n    },\\n\\n    _onFail: function (jqXHR, textStatus, errorThrown, options) {\\n      var response = options._response;\\n      if (options.recalculateProgress) {\\n        // Remove the failed (error or abort) file upload from\\n        // the global progress calculation:\\n        this._progress.loaded -= options._progress.loaded;\\n        this._progress.total -= options._progress.total;\\n      }\\n      response.jqXHR = options.jqXHR = jqXHR;\\n      response.textStatus = options.textStatus = textStatus;\\n      response.errorThrown = options.errorThrown = errorThrown;\\n      this._trigger('fail', null, options);\\n    },\\n\\n    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\\n      // jqXHRorResult, textStatus and jqXHRorError are added to the\\n      // options object via done and fail callbacks\\n      this._trigger('always', null, options);\\n    },\\n\\n    _onSend: function (e, data) {\\n      if (!data.submit) {\\n        this._addConvenienceMethods(e, data);\\n      }\\n      var that = this,\\n        jqXHR,\\n        aborted,\\n        slot,\\n        pipe,\\n        options = that._getAJAXSettings(data),\\n        send = function () {\\n          that._sending += 1;\\n          // Set timer for bitrate progress calculation:\\n          options._bitrateTimer = new that._BitrateTimer();\\n          jqXHR =\\n            jqXHR ||\\n            (\\n              ((aborted ||\\n                that._trigger(\\n                  'send',\\n                  $.Event('send', { delegatedEvent: e }),\\n                  options\\n                ) === false) &&\\n                that._getXHRPromise(false, options.context, aborted)) ||\\n              that._chunkedUpload(options) ||\\n              $.ajax(options)\\n            )\\n              .done(function (result, textStatus, jqXHR) {\\n                that._onDone(result, textStatus, jqXHR, options);\\n              })\\n              .fail(function (jqXHR, textStatus, errorThrown) {\\n                that._onFail(jqXHR, textStatus, errorThrown, options);\\n              })\\n              .always(function (jqXHRorResult, textStatus, jqXHRorError) {\\n                that._deinitProgressListener(options);\\n                that._onAlways(\\n                  jqXHRorResult,\\n                  textStatus,\\n                  jqXHRorError,\\n                  options\\n                );\\n                that._sending -= 1;\\n                that._active -= 1;\\n                if (\\n                  options.limitConcurrentUploads &&\\n                  options.limitConcurrentUploads > that._sending\\n                ) {\\n                  // Start the next queued upload,\\n                  // that has not been aborted:\\n                  var nextSlot = that._slots.shift();\\n                  while (nextSlot) {\\n                    if (that._getDeferredState(nextSlot) === 'pending') {\\n                      nextSlot.resolve();\\n                      break;\\n                    }\\n                    nextSlot = that._slots.shift();\\n                  }\\n                }\\n                if (that._active === 0) {\\n                  // The stop callback is triggered when all uploads have\\n                  // been completed, equivalent to the global ajaxStop event:\\n                  that._trigger('stop');\\n                }\\n              });\\n          return jqXHR;\\n        };\\n      this._beforeSend(e, options);\\n      if (\\n        this.options.sequentialUploads ||\\n        (this.options.limitConcurrentUploads &&\\n          this.options.limitConcurrentUploads <= this._sending)\\n      ) {\\n        if (this.options.limitConcurrentUploads > 1) {\\n          slot = $.Deferred();\\n          this._slots.push(slot);\\n          pipe = slot[that._promisePipe](send);\\n        } else {\\n          this._sequence = this._sequence[that._promisePipe](send, send);\\n          pipe = this._sequence;\\n        }\\n        // Return the piped Promise object, enhanced with an abort method,\\n        // which is delegated to the jqXHR object of the current upload,\\n        // and jqXHR callbacks mapped to the equivalent Promise methods:\\n        pipe.abort = function () {\\n          aborted = [undefined, 'abort', 'abort'];\\n          if (!jqXHR) {\\n            if (slot) {\\n              slot.rejectWith(options.context, aborted);\\n            }\\n            return send();\\n          }\\n          return jqXHR.abort();\\n        };\\n        return this._enhancePromise(pipe);\\n      }\\n      return send();\\n    },\\n\\n    _onAdd: function (e, data) {\\n      var that = this,\\n        result = true,\\n        options = $.extend({}, this.options, data),\\n        files = data.files,\\n        filesLength = files.length,\\n        limit = options.limitMultiFileUploads,\\n        limitSize = options.limitMultiFileUploadSize,\\n        overhead = options.limitMultiFileUploadSizeOverhead,\\n        batchSize = 0,\\n        paramName = this._getParamName(options),\\n        paramNameSet,\\n        paramNameSlice,\\n        fileSet,\\n        i,\\n        j = 0;\\n      if (!filesLength) {\\n        return false;\\n      }\\n      if (limitSize && files[0].size === undefined) {\\n        limitSize = undefined;\\n      }\\n      if (\\n        !(options.singleFileUploads || limit || limitSize) ||\\n        !this._isXHRUpload(options)\\n      ) {\\n        fileSet = [files];\\n        paramNameSet = [paramName];\\n      } else if (!(options.singleFileUploads || limitSize) && limit) {\\n        fileSet = [];\\n        paramNameSet = [];\\n        for (i = 0; i < filesLength; i += limit) {\\n          fileSet.push(files.slice(i, i + limit));\\n          paramNameSlice = paramName.slice(i, i + limit);\\n          if (!paramNameSlice.length) {\\n            paramNameSlice = paramName;\\n          }\\n          paramNameSet.push(paramNameSlice);\\n        }\\n      } else if (!options.singleFileUploads && limitSize) {\\n        fileSet = [];\\n        paramNameSet = [];\\n        for (i = 0; i < filesLength; i = i + 1) {\\n          batchSize += files[i].size + overhead;\\n          if (\\n            i + 1 === filesLength ||\\n            batchSize + files[i + 1].size + overhead > limitSize ||\\n            (limit && i + 1 - j >= limit)\\n          ) {\\n            fileSet.push(files.slice(j, i + 1));\\n            paramNameSlice = paramName.slice(j, i + 1);\\n            if (!paramNameSlice.length) {\\n              paramNameSlice = paramName;\\n            }\\n            paramNameSet.push(paramNameSlice);\\n            j = i + 1;\\n            batchSize = 0;\\n          }\\n        }\\n      } else {\\n        paramNameSet = paramName;\\n      }\\n      data.originalFiles = files;\\n      $.each(fileSet || files, function (index, element) {\\n        var newData = $.extend({}, data);\\n        newData.files = fileSet ? element : [element];\\n        newData.paramName = paramNameSet[index];\\n        that._initResponseObject(newData);\\n        that._initProgressObject(newData);\\n        that._addConvenienceMethods(e, newData);\\n        result = that._trigger(\\n          'add',\\n          $.Event('add', { delegatedEvent: e }),\\n          newData\\n        );\\n        return result;\\n      });\\n      return result;\\n    },\\n\\n    _replaceFileInput: function (data) {\\n      var input = data.fileInput,\\n        inputClone = input.clone(true),\\n        restoreFocus = input.is(document.activeElement);\\n      // Add a reference for the new cloned file input to the data argument:\\n      data.fileInputClone = inputClone;\\n      $('<form></form>').append(inputClone)[0].reset();\\n      // Detaching allows to insert the fileInput on another form\\n      // without loosing the file input value:\\n      input.after(inputClone).detach();\\n      // If the fileInput had focus before it was detached,\\n      // restore focus to the inputClone.\\n      if (restoreFocus) {\\n        inputClone.trigger('focus');\\n      }\\n      // Avoid memory leaks with the detached file input:\\n      $.cleanData(input.off('remove'));\\n      // Replace the original file input element in the fileInput\\n      // elements set with the clone, which has been copied including\\n      // event handlers:\\n      this.options.fileInput = this.options.fileInput.map(function (i, el) {\\n        if (el === input[0]) {\\n          return inputClone[0];\\n        }\\n        return el;\\n      });\\n      // If the widget has been initialized on the file input itself,\\n      // override this.element with the file input clone:\\n      if (input[0] === this.element[0]) {\\n        this.element = inputClone;\\n      }\\n    },\\n\\n    _handleFileTreeEntry: function (entry, path) {\\n      var that = this,\\n        dfd = $.Deferred(),\\n        entries = [],\\n        dirReader,\\n        errorHandler = function (e) {\\n          if (e && !e.entry) {\\n            e.entry = entry;\\n          }\\n          // Since $.when returns immediately if one\\n          // Deferred is rejected, we use resolve instead.\\n          // This allows valid files and invalid items\\n          // to be returned together in one set:\\n          dfd.resolve([e]);\\n        },\\n        successHandler = function (entries) {\\n          that\\n            ._handleFileTreeEntries(entries, path + entry.name + '/')\\n            .done(function (files) {\\n              dfd.resolve(files);\\n            })\\n            .fail(errorHandler);\\n        },\\n        readEntries = function () {\\n          dirReader.readEntries(function (results) {\\n            if (!results.length) {\\n              successHandler(entries);\\n            } else {\\n              entries = entries.concat(results);\\n              readEntries();\\n            }\\n          }, errorHandler);\\n        };\\n      // eslint-disable-next-line no-param-reassign\\n      path = path || '';\\n      if (entry.isFile) {\\n        if (entry._file) {\\n          // Workaround for Chrome bug #149735\\n          entry._file.relativePath = path;\\n          dfd.resolve(entry._file);\\n        } else {\\n          entry.file(function (file) {\\n            file.relativePath = path;\\n            dfd.resolve(file);\\n          }, errorHandler);\\n        }\\n      } else if (entry.isDirectory) {\\n        dirReader = entry.createReader();\\n        readEntries();\\n      } else {\\n        // Return an empty list for file system items\\n        // other than files or directories:\\n        dfd.resolve([]);\\n      }\\n      return dfd.promise();\\n    },\\n\\n    _handleFileTreeEntries: function (entries, path) {\\n      var that = this;\\n      return $.when\\n        .apply(\\n          $,\\n          $.map(entries, function (entry) {\\n            return that._handleFileTreeEntry(entry, path);\\n          })\\n        )\\n        [this._promisePipe](function () {\\n          return Array.prototype.concat.apply([], arguments);\\n        });\\n    },\\n\\n    _getDroppedFiles: function (dataTransfer) {\\n      // eslint-disable-next-line no-param-reassign\\n      dataTransfer = dataTransfer || {};\\n      var items = dataTransfer.items;\\n      if (\\n        items &&\\n        items.length &&\\n        (items[0].webkitGetAsEntry || items[0].getAsEntry)\\n      ) {\\n        return this._handleFileTreeEntries(\\n          $.map(items, function (item) {\\n            var entry;\\n            if (item.webkitGetAsEntry) {\\n              entry = item.webkitGetAsEntry();\\n              if (entry) {\\n                // Workaround for Chrome bug #149735:\\n                entry._file = item.getAsFile();\\n              }\\n              return entry;\\n            }\\n            return item.getAsEntry();\\n          })\\n        );\\n      }\\n      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();\\n    },\\n\\n    _getSingleFileInputFiles: function (fileInput) {\\n      // eslint-disable-next-line no-param-reassign\\n      fileInput = $(fileInput);\\n      var entries =\\n          fileInput.prop('webkitEntries') || fileInput.prop('entries'),\\n        files,\\n        value;\\n      if (entries && entries.length) {\\n        return this._handleFileTreeEntries(entries);\\n      }\\n      files = $.makeArray(fileInput.prop('files'));\\n      if (!files.length) {\\n        value = fileInput.prop('value');\\n        if (!value) {\\n          return $.Deferred().resolve([]).promise();\\n        }\\n        // If the files property is not available, the browser does not\\n        // support the File API and we add a pseudo File object with\\n        // the input value as name with path information removed:\\n        files = [{ name: value.replace(/^.*\\\\\\\\/, '') }];\\n      } else if (files[0].name === undefined && files[0].fileName) {\\n        // File normalization for Safari 4 and Firefox 3:\\n        $.each(files, function (index, file) {\\n          file.name = file.fileName;\\n          file.size = file.fileSize;\\n        });\\n      }\\n      return $.Deferred().resolve(files).promise();\\n    },\\n\\n    _getFileInputFiles: function (fileInput) {\\n      if (!(fileInput instanceof $) || fileInput.length === 1) {\\n        return this._getSingleFileInputFiles(fileInput);\\n      }\\n      return $.when\\n        .apply($, $.map(fileInput, this._getSingleFileInputFiles))\\n        [this._promisePipe](function () {\\n          return Array.prototype.concat.apply([], arguments);\\n        });\\n    },\\n\\n    _onChange: function (e) {\\n      var that = this,\\n        data = {\\n          fileInput: $(e.target),\\n          form: $(e.target.form)\\n        };\\n      this._getFileInputFiles(data.fileInput).always(function (files) {\\n        data.files = files;\\n        if (that.options.replaceFileInput) {\\n          that._replaceFileInput(data);\\n        }\\n        if (\\n          that._trigger(\\n            'change',\\n            $.Event('change', { delegatedEvent: e }),\\n            data\\n          ) !== false\\n        ) {\\n          that._onAdd(e, data);\\n        }\\n      });\\n    },\\n\\n    _onPaste: function (e) {\\n      var items =\\n          e.originalEvent &&\\n          e.originalEvent.clipboardData &&\\n          e.originalEvent.clipboardData.items,\\n        data = { files: [] };\\n      if (items && items.length) {\\n        $.each(items, function (index, item) {\\n          var file = item.getAsFile && item.getAsFile();\\n          if (file) {\\n            data.files.push(file);\\n          }\\n        });\\n        if (\\n          this._trigger(\\n            'paste',\\n            $.Event('paste', { delegatedEvent: e }),\\n            data\\n          ) !== false\\n        ) {\\n          this._onAdd(e, data);\\n        }\\n      }\\n    },\\n\\n    _onDrop: function (e) {\\n      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;\\n      var that = this,\\n        dataTransfer = e.dataTransfer,\\n        data = {};\\n      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\\n        e.preventDefault();\\n        this._getDroppedFiles(dataTransfer).always(function (files) {\\n          data.files = files;\\n          if (\\n            that._trigger(\\n              'drop',\\n              $.Event('drop', { delegatedEvent: e }),\\n              data\\n            ) !== false\\n          ) {\\n            that._onAdd(e, data);\\n          }\\n        });\\n      }\\n    },\\n\\n    _onDragOver: getDragHandler('dragover'),\\n\\n    _onDragEnter: getDragHandler('dragenter'),\\n\\n    _onDragLeave: getDragHandler('dragleave'),\\n\\n    _initEventHandlers: function () {\\n      if (this._isXHRUpload(this.options)) {\\n        this._on(this.options.dropZone, {\\n          dragover: this._onDragOver,\\n          drop: this._onDrop,\\n          // event.preventDefault() on dragenter is required for IE10+:\\n          dragenter: this._onDragEnter,\\n          // dragleave is not required, but added for completeness:\\n          dragleave: this._onDragLeave\\n        });\\n        this._on(this.options.pasteZone, {\\n          paste: this._onPaste\\n        });\\n      }\\n      if ($.support.fileInput) {\\n        this._on(this.options.fileInput, {\\n          change: this._onChange\\n        });\\n      }\\n    },\\n\\n    _destroyEventHandlers: function () {\\n      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');\\n      this._off(this.options.pasteZone, 'paste');\\n      this._off(this.options.fileInput, 'change');\\n    },\\n\\n    _destroy: function () {\\n      this._destroyEventHandlers();\\n    },\\n\\n    _setOption: function (key, value) {\\n      var reinit = $.inArray(key, this._specialOptions) !== -1;\\n      if (reinit) {\\n        this._destroyEventHandlers();\\n      }\\n      this._super(key, value);\\n      if (reinit) {\\n        this._initSpecialOptions();\\n        this._initEventHandlers();\\n      }\\n    },\\n\\n    _initSpecialOptions: function () {\\n      var options = this.options;\\n      if (options.fileInput === undefined) {\\n        options.fileInput = this.element.is('input[type=\\\"file\\\"]')\\n          ? this.element\\n          : this.element.find('input[type=\\\"file\\\"]');\\n      } else if (!(options.fileInput instanceof $)) {\\n        options.fileInput = $(options.fileInput);\\n      }\\n      if (!(options.dropZone instanceof $)) {\\n        options.dropZone = $(options.dropZone);\\n      }\\n      if (!(options.pasteZone instanceof $)) {\\n        options.pasteZone = $(options.pasteZone);\\n      }\\n    },\\n\\n    _getRegExp: function (str) {\\n      var parts = str.split('/'),\\n        modifiers = parts.pop();\\n      parts.shift();\\n      return new RegExp(parts.join('/'), modifiers);\\n    },\\n\\n    _isRegExpOption: function (key, value) {\\n      return (\\n        key !== 'url' &&\\n        $.type(value) === 'string' &&\\n        /^\\\\/.*\\\\/[igm]{0,3}$/.test(value)\\n      );\\n    },\\n\\n    _initDataAttributes: function () {\\n      var that = this,\\n        options = this.options,\\n        data = this.element.data();\\n      // Initialize options set via HTML5 data-attributes:\\n      $.each(this.element[0].attributes, function (index, attr) {\\n        var key = attr.name.toLowerCase(),\\n          value;\\n        if (/^data-/.test(key)) {\\n          // Convert hyphen-ated key to camelCase:\\n          key = key.slice(5).replace(/-[a-z]/g, function (str) {\\n            return str.charAt(1).toUpperCase();\\n          });\\n          value = data[key];\\n          if (that._isRegExpOption(key, value)) {\\n            value = that._getRegExp(value);\\n          }\\n          options[key] = value;\\n        }\\n      });\\n    },\\n\\n    _create: function () {\\n      this._initDataAttributes();\\n      this._initSpecialOptions();\\n      this._slots = [];\\n      this._sequence = this._getXHRPromise(true);\\n      this._sending = this._active = 0;\\n      this._initProgressObject(this);\\n      this._initEventHandlers();\\n    },\\n\\n    // This method is exposed to the widget API and allows to query\\n    // the number of active uploads:\\n    active: function () {\\n      return this._active;\\n    },\\n\\n    // This method is exposed to the widget API and allows to query\\n    // the widget upload progress.\\n    // It returns an object with loaded, total and bitrate properties\\n    // for the running uploads:\\n    progress: function () {\\n      return this._progress;\\n    },\\n\\n    // This method is exposed to the widget API and allows adding files\\n    // using the fileupload API. The data parameter accepts an object which\\n    // must have a files property and can contain additional options:\\n    // .fileupload('add', {files: filesList});\\n    add: function (data) {\\n      var that = this;\\n      if (!data || this.options.disabled) {\\n        return;\\n      }\\n      if (data.fileInput && !data.files) {\\n        this._getFileInputFiles(data.fileInput).always(function (files) {\\n          data.files = files;\\n          that._onAdd(null, data);\\n        });\\n      } else {\\n        data.files = $.makeArray(data.files);\\n        this._onAdd(null, data);\\n      }\\n    },\\n\\n    // This method is exposed to the widget API and allows sending files\\n    // using the fileupload API. The data parameter accepts an object which\\n    // must have a files or fileInput property and can contain additional options:\\n    // .fileupload('send', {files: filesList});\\n    // The method returns a Promise object for the file upload call.\\n    send: function (data) {\\n      if (data && !this.options.disabled) {\\n        if (data.fileInput && !data.files) {\\n          var that = this,\\n            dfd = $.Deferred(),\\n            promise = dfd.promise(),\\n            jqXHR,\\n            aborted;\\n          promise.abort = function () {\\n            aborted = true;\\n            if (jqXHR) {\\n              return jqXHR.abort();\\n            }\\n            dfd.reject(null, 'abort', 'abort');\\n            return promise;\\n          };\\n          this._getFileInputFiles(data.fileInput).always(function (files) {\\n            if (aborted) {\\n              return;\\n            }\\n            if (!files.length) {\\n              dfd.reject();\\n              return;\\n            }\\n            data.files = files;\\n            jqXHR = that._onSend(null, data);\\n            jqXHR.then(\\n              function (result, textStatus, jqXHR) {\\n                dfd.resolve(result, textStatus, jqXHR);\\n              },\\n              function (jqXHR, textStatus, errorThrown) {\\n                dfd.reject(jqXHR, textStatus, errorThrown);\\n              }\\n            );\\n          });\\n          return this._enhancePromise(promise);\\n        }\\n        data.files = $.makeArray(data.files);\\n        if (data.files.length) {\\n          return this._onSend(null, data);\\n        }\\n      }\\n      return this._getXHRPromise(false, data && data.context);\\n    }\\n  });\\n});\\n\"","require(\"!!/tmp/glpi-9.5.4/glpi/node_modules/script-loader/addScript.js\")(require(\"!!/tmp/glpi-9.5.4/glpi/node_modules/raw-loader/index.js!/tmp/glpi-9.5.4/glpi/node_modules/strip-sourcemap-loader/index.js!/tmp/glpi-9.5.4/glpi/vendor/blueimp/jquery-file-upload/js/jquery.iframe-transport.js\"))","module.exports = \"/*\\n * jQuery Iframe Transport Plugin\\n * https://github.com/blueimp/jQuery-File-Upload\\n *\\n * Copyright 2011, Sebastian Tschan\\n * https://blueimp.net\\n *\\n * Licensed under the MIT license:\\n * https://opensource.org/licenses/MIT\\n */\\n\\n/* global define, require */\\n\\n(function (factory) {\\n  'use strict';\\n  if (typeof define === 'function' && define.amd) {\\n    // Register as an anonymous AMD module:\\n    define(['jquery'], factory);\\n  } else if (typeof exports === 'object') {\\n    // Node/CommonJS:\\n    factory(require('jquery'));\\n  } else {\\n    // Browser globals:\\n    factory(window.jQuery);\\n  }\\n})(function ($) {\\n  'use strict';\\n\\n  // Helper variable to create unique names for the transport iframes:\\n  var counter = 0,\\n    jsonAPI = $,\\n    jsonParse = 'parseJSON';\\n\\n  if ('JSON' in window && 'parse' in JSON) {\\n    jsonAPI = JSON;\\n    jsonParse = 'parse';\\n  }\\n\\n  // The iframe transport accepts four additional options:\\n  // options.fileInput: a jQuery collection of file input fields\\n  // options.paramName: the parameter name for the file form data,\\n  //  overrides the name property of the file input field(s),\\n  //  can be a string or an array of strings.\\n  // options.formData: an array of objects with name and value properties,\\n  //  equivalent to the return data of .serializeArray(), e.g.:\\n  //  [{name: 'a', value: 1}, {name: 'b', value: 2}]\\n  // options.initialIframeSrc: the URL of the initial iframe src,\\n  //  by default set to \\\"javascript:false;\\\"\\n  $.ajaxTransport('iframe', function (options) {\\n    if (options.async) {\\n      // javascript:false as initial iframe src\\n      // prevents warning popups on HTTPS in IE6:\\n      // eslint-disable-next-line no-script-url\\n      var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',\\n        form,\\n        iframe,\\n        addParamChar;\\n      return {\\n        send: function (_, completeCallback) {\\n          form = $('<form style=\\\"display:none;\\\"></form>');\\n          form.attr('accept-charset', options.formAcceptCharset);\\n          addParamChar = /\\\\?/.test(options.url) ? '&' : '?';\\n          // XDomainRequest only supports GET and POST:\\n          if (options.type === 'DELETE') {\\n            options.url = options.url + addParamChar + '_method=DELETE';\\n            options.type = 'POST';\\n          } else if (options.type === 'PUT') {\\n            options.url = options.url + addParamChar + '_method=PUT';\\n            options.type = 'POST';\\n          } else if (options.type === 'PATCH') {\\n            options.url = options.url + addParamChar + '_method=PATCH';\\n            options.type = 'POST';\\n          }\\n          // IE versions below IE8 cannot set the name property of\\n          // elements that have already been added to the DOM,\\n          // so we set the name along with the iframe HTML markup:\\n          counter += 1;\\n          iframe = $(\\n            '<iframe src=\\\"' +\\n              initialIframeSrc +\\n              '\\\" name=\\\"iframe-transport-' +\\n              counter +\\n              '\\\"></iframe>'\\n          ).on('load', function () {\\n            var fileInputClones,\\n              paramNames = $.isArray(options.paramName)\\n                ? options.paramName\\n                : [options.paramName];\\n            iframe.off('load').on('load', function () {\\n              var response;\\n              // Wrap in a try/catch block to catch exceptions thrown\\n              // when trying to access cross-domain iframe contents:\\n              try {\\n                response = iframe.contents();\\n                // Google Chrome and Firefox do not throw an\\n                // exception when calling iframe.contents() on\\n                // cross-domain requests, so we unify the response:\\n                if (!response.length || !response[0].firstChild) {\\n                  throw new Error();\\n                }\\n              } catch (e) {\\n                response = undefined;\\n              }\\n              // The complete callback returns the\\n              // iframe content document as response object:\\n              completeCallback(200, 'success', { iframe: response });\\n              // Fix for IE endless progress bar activity bug\\n              // (happens on form submits to iframe targets):\\n              $('<iframe src=\\\"' + initialIframeSrc + '\\\"></iframe>').appendTo(\\n                form\\n              );\\n              window.setTimeout(function () {\\n                // Removing the form in a setTimeout call\\n                // allows Chrome's developer tools to display\\n                // the response result\\n                form.remove();\\n              }, 0);\\n            });\\n            form\\n              .prop('target', iframe.prop('name'))\\n              .prop('action', options.url)\\n              .prop('method', options.type);\\n            if (options.formData) {\\n              $.each(options.formData, function (index, field) {\\n                $('<input type=\\\"hidden\\\"/>')\\n                  .prop('name', field.name)\\n                  .val(field.value)\\n                  .appendTo(form);\\n              });\\n            }\\n            if (\\n              options.fileInput &&\\n              options.fileInput.length &&\\n              options.type === 'POST'\\n            ) {\\n              fileInputClones = options.fileInput.clone();\\n              // Insert a clone for each file input field:\\n              options.fileInput.after(function (index) {\\n                return fileInputClones[index];\\n              });\\n              if (options.paramName) {\\n                options.fileInput.each(function (index) {\\n                  $(this).prop('name', paramNames[index] || options.paramName);\\n                });\\n              }\\n              // Appending the file input fields to the hidden form\\n              // removes them from their original location:\\n              form\\n                .append(options.fileInput)\\n                .prop('enctype', 'multipart/form-data')\\n                // enctype must be set as encoding for IE:\\n                .prop('encoding', 'multipart/form-data');\\n              // Remove the HTML5 form attribute from the input(s):\\n              options.fileInput.removeAttr('form');\\n            }\\n            window.setTimeout(function () {\\n              // Submitting the form in a setTimeout call fixes an issue with\\n              // Safari 13 not triggering the iframe load event after resetting\\n              // the load event handler, see also:\\n              // https://github.com/blueimp/jQuery-File-Upload/issues/3633\\n              form.submit();\\n              // Insert the file input fields at their original location\\n              // by replacing the clones with the originals:\\n              if (fileInputClones && fileInputClones.length) {\\n                options.fileInput.each(function (index, input) {\\n                  var clone = $(fileInputClones[index]);\\n                  // Restore the original name and form properties:\\n                  $(input)\\n                    .prop('name', clone.prop('name'))\\n                    .attr('form', clone.attr('form'));\\n                  clone.replaceWith(input);\\n                });\\n              }\\n            }, 0);\\n          });\\n          form.append(iframe).appendTo(document.body);\\n        },\\n        abort: function () {\\n          if (iframe) {\\n            // javascript:false as iframe src aborts the request\\n            // and prevents warning popups on HTTPS in IE6.\\n            iframe.off('load').prop('src', initialIframeSrc);\\n          }\\n          if (form) {\\n            form.remove();\\n          }\\n        }\\n      };\\n    }\\n  });\\n\\n  // The iframe transport returns the iframe content document as response.\\n  // The following adds converters from iframe to text, json, html, xml\\n  // and script.\\n  // Please note that the Content-Type for JSON responses has to be text/plain\\n  // or text/html, if the browser doesn't include application/json in the\\n  // Accept header, else IE will show a download dialog.\\n  // The Content-Type for XML responses on the other hand has to be always\\n  // application/xml or text/xml, so IE properly parses the XML response.\\n  // See also\\n  // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation\\n  $.ajaxSetup({\\n    converters: {\\n      'iframe text': function (iframe) {\\n        return iframe && $(iframe[0].body).text();\\n      },\\n      'iframe json': function (iframe) {\\n        return iframe && jsonAPI[jsonParse]($(iframe[0].body).text());\\n      },\\n      'iframe html': function (iframe) {\\n        return iframe && $(iframe[0].body).html();\\n      },\\n      'iframe xml': function (iframe) {\\n        var xmlDoc = iframe && iframe[0];\\n        return xmlDoc && $.isXMLDoc(xmlDoc)\\n          ? xmlDoc\\n          : $.parseXML(\\n              (xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||\\n                $(xmlDoc.body).html()\\n            );\\n      },\\n      'iframe script': function (iframe) {\\n        return iframe && $.globalEval($(iframe[0].body).text());\\n      }\\n    }\\n  });\\n});\\n\"","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}"],"sourceRoot":""}